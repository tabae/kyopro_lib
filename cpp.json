{	
	  "bellman_ford_snippets": {
		"prefix": "bellman_ford_snippets",
		"body": [
		  "namespace bellman {",
		  "",
		  "    const ll inf = 1LL<<60;",
		  "",
		  "    typedef struct EdgeInfo{",
		  "        ll from;",
		  "        ll to;",
		  "        ll cost;",
		  "        EdgeInfo() {};",
		  "        EdgeInfo(ll _from, ll _to, ll _cost) : from(_from), to(_to), cost(_cost) {};",
		  "    } edge;",
		  "",
		  "    vector<pair<ll,bool>> bellman_ford(ll n, vector<edge> E) {",
		  "        ",
		  "        ll m = E.size();",
		  "        vector<ll> d(n, inf);",
		  "        ",
		  "        // グラフ全体での負経路検出",
		  "        bool closed_loop = false;",
		  "",
		  "        ll srt = 0;",
		  "        d[srt] = 0;",
		  "        rep(i, 0, n){",
		  "            rep(j, 0, m){",
		  "                auto e = E[j];",
		  "                if(d[e.to] > d[e.from] + e.cost){",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    if(i == n-1){",
		  "                        closed_loop = true;",
		  "                        break;",
		  "                    }",
		  "                }",
		  "            }",
		  "            if(closed_loop) break;",
		  "        }",
		  "",
		  "        vector<pair<ll,bool>> res(n);",
		  "        rep(i, 0, n) res[i].first = d[i];",
		  "",
		  "        // 各頂点への経路中の負閉路検出",
		  "        vector<bool> neg(n, false);",
		  "",
		  "        rep(loop, 0, n) {",
		  "            rep(i, 0, m) {",
		  "                auto e = E[i];",
		  "                if(d[e.from] == inf) continue;",
		  "                if(d[e.to] > d[e.from] + e.cost) {",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    neg[e.to] = true;",
		  "                }",
		  "                if(neg[e.from]) neg[e.to] = true;",
		  "            }",
		  "        }",
		  "",
		  "        rep(i, 0, n) res[i].second = neg[i];",
		  "        return res;",
		  "    }",
		  "    // res.second == true のとき，答えは無限に小さくなりえる．",
		  "};"
		],
		"description": ""
	  },
	  "LCS": {
		"prefix": "LCS",
		"body": [
		  "string LCS(string s, string t){",
		  "    ll ns = s.size();",
		  "    ll nt = t.size();",
		  "    vector< vector<ll> > dp(ns+1, vector<ll> (nt+1, 0));",
		  "    // initilaize",
		  "    rep(i, 0, ns){",
		  "        if(s[i] == t[0]) dp[i][0] = 1;",
		  "    }",
		  "    rep(i, 0, nt){",
		  "        if(s[0] == t[i]) dp[0][i] = 1;",
		  "    }",
		  "    // build DP table",
		  "    rep(i, 1, ns){",
		  "        rep(j, 1, nt){",
		  "            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);",
		  "            if(s[i] == t[j]){",
		  "                dp[i][j] = dp[i-1][j-1] + 1;",
		  "            }",
		  "        }",
		  "    }",
		  "    // make LCS",
		  "    string ret;",
		  "    ll i = ns-1, j = nt-1;",
		  "    while(i >= 0 && j >= 0){",
		  "        if(s[i] == t[j]){",
		  "            ret.push_back(s[i]);",
		  "            i--; j--;",
		  "        }else{",
		  "            if(j == 0) i--;",
		  "            else if(i == 0) j--;",
		  "            else if(dp[i-1][j] > dp[i][j-1]) i--;",
		  "            else j--;",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "centroid_snippets": {
		"prefix": "centroid_snippets",
		"body": [
		  "/*-------------ここから---------------*/",
		  "using _ll = long long;",
		  "vector<_ll> _max_subtree, _sum_subtree;",
		  "_ll _centroid1(vector<vector<_ll>>& G, _ll cur, _ll par, _ll N) {",
		  "    _ll mx = 0, sum = 0;",
		  "    for(auto g : G[cur]) {",
		  "        if(g == par) continue;",
		  "        _ll tmp = _centroid1(G, g, cur, N);",
		  "        sum += tmp;",
		  "        mx = max(mx, tmp);",
		  "    }",
		  "    mx = max(mx, N - sum - 1);",
		  "    _max_subtree[cur] = mx;",
		  "    _sum_subtree[cur] = sum;",
		  "    return sum + 1;",
		  "}",
		  "vector<_ll> _centroid2(_ll N) {",
		  "    vector<_ll> res;",
		  "    _ll mn = 1LL<<60;",
		  "    for(_ll i = 0; i < N; i++) mn = min(mn, _max_subtree[i]);",
		  "    for(_ll i = 0; i < N; i++) if(_max_subtree[i] == mn) res.push_back(i);",
		  "    return res;",
		  "}",
		  "vector<_ll> find_centroids(vector<vector<_ll>>& G, _ll N) {",
		  "    _max_subtree = vector<_ll>(N, 0);",
		  "    _sum_subtree = vector<_ll>(N, 0);",
		  "    _centroid1(G, 0, -1, N);",
		  "    return _centroid2(N);",
		  "}",
		  "/*-------------ここまで---------------*/"
		],
		"description": ""
	  },
	  "dump_snippets": {
		"prefix": "dump_snippets",
		"body": [
		  "// For debug",
		  "// Ref: https://qiita.com/ysuzuki19/items/d89057d65284ba1a16ac",
		  "#define dump(var)  do{std::cerr << #var << \" : \";view(var);}while(0)",
		  "template<typename T> void view(T e){std::cerr << e << \"\\n\";}",
		  "template<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cerr << e << \" \"; } std::cerr << \"\\n\";}",
		  "template<typename T> void view(const std::vector<std::vector<T> >& vv){ std::cerr << \"\\n\"; for(const auto& v : vv){ view(v); } }",
		  "template<typename T> void dump_cout(const T& v) { for(long long i = 0; i < v.size(); i++) std::cout << v[i] << (i == v.size()-1 ? \"\\n\" : \" \"); }"
		],
		"description": ""
	  },
	  "tree_diameter_snippets": {
		"prefix": "tree_diameter_snippets",
		"body": [
		  "// first: distance, second: node id",
		  "pair<ll,ll> farthest_node(vector<vector<ll>>& G, ll cur, ll par) {",
		  "    ll res = 0, id = cur;",
		  "    for(auto e : G[cur]) {",
		  "        if(e == par) continue;",
		  "        auto t = farthest_node(G, e, cur);",
		  "        if(res < t.first + 1) {",
		  "            res = t.first + 1;",
		  "            id = t.second;",
		  "        }",
		  "    }",
		  "    return {res, id};",
		  "}",
		  "",
		  "pair<ll,ll> farthest_node(vector<vector<pair<ll,ll>>>& G, ll cur, ll par) {",
		  "    ll res = 0, id = cur;",
		  "    for(auto e : G[cur]) {",
		  "        if(e.first == par) continue;",
		  "        auto t = farthest_node(G, e.first, cur);",
		  "        if(res < t.first + e.second) {",
		  "            res = t.first + e.second;",
		  "            id = t.second;",
		  "        }",
		  "    }",
		  "    return {res, id};",
		  "}",
		  "",
		  "ll tree_diameter(vector<vector<ll>>& G) {",
		  "    auto x = farthest_node(G, 0, -1);",
		  "    auto y = farthest_node(G, x.second, -1);",
		  "    return y.first;",
		  "}",
		  "",
		  "ll tree_diameter(vector<vector<pair<ll,ll>>>& G) {",
		  "    auto x = farthest_node(G, 0, -1);",
		  "    auto y = farthest_node(G, x.second, -1);",
		  "    return y.first;",
		  "}"
		],
		"description": ""
	  },
	  "largestRectangle": {
		"prefix": "largest_rectangle_snippets",
		"body": [
		  "template <class T> ",
		  "T largestRectangle(vector<T> a) {",
		  "    a.push_back(0);",
		  "    int n = a.size();",
		  "    stack<int> st;",
		  "    vector<T> left(n);",
		  "    ll res = 0;",
		  "    rep(i, 0, n) {",
		  "        while(!st.empty() && a[st.top()] >= a[i]) {",
		  "            res = max(res, 1LL * (i - left[st.top()] - 1) * a[st.top()]);",
		  "            st.pop();",
		  "        }",
		  "        left[i] = st.empty() ? -1 : st.top();",
		  "        st.push(i);",
		  "    }",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  }
	}