{

	"cin_vector_int":{
        "prefix": "cvi",
        "body":[
            "vector<int> $1($2);",
            "rep(i, $2, $3) cin >> $1[i];",
            "$3"
        ],
        "description": "vector<int>の受取"
	},
	
	"gcdlcm": {
		"prefix": "gcdlcm",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll lcm(ll a, ll b){",
		  "    ll ret = a / gcd(a,b) * b;",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },

	  "is_prime": {
		"prefix": "is_prime_snippets",
		"body": [
		  "bool is_prime(long long n) {",
		  "    if(n == 1) return false;",
		  "    for(long long val = 2; val * val <= n; val++) {",
		  "        if(n % val == 0) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },

	  "factorize": {
		"prefix": "factorize",
		"body": [
		  "vector<ll> factorize(ll g){",
		  "    if(g == 1){",
		  "        return {};",
		  "    }",
		  "    ll d = 2;",
		  "    vector<ll> ret;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                g /= d;",
		  "            }",
		  "            ret.push_back(d);",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret.push_back(g);",
		  "    return ret;",
		  "}"
		],
		"description": "factorize"
	  },

	  "keta_sum": {
		"prefix": "ketasum",
		"body": [
		  "ll keta_sum(ll a){",
		  "    ll ret = 0;",
		  "    while(a > 0){",
		  "        ret += a%10;",
		  "        a /= 10;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "sum of digits"
	  },

	  "keta_bunkai": {
		"prefix": "ketabunkai",
		"body": [
		  "vector<ll> keta_bunkai(ll a){",
		  "    string s = to_string(a);",
		  "    vector<ll> ret;",
		  "    for(auto p : s){",
		  "        ret.push_back((ll)(p - '0'));",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "keta bunkai"
	  },

	  "distance": {
		"prefix": "dist",
		"body": [
		  "template<typename T> T dist(T x0, T y0, T x, T y){",
		  "    T ret = sqrt((x-x0)*(x-x0) + (y-y0)*(y-y0));",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": "distance between two grid point"
	  },
	  
	  "normal_nck": {
		"prefix": "normal_nck",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll nck(ll n, ll k){",
		  "  if (n < k) return 0;",
		  "  if (n < 0 || k < 0) return 0;",
		  "  if(k == 0 || k == n) return 1;",
		  "  ll nume = 1, deno = 1;",
		  "  for(int i=0; i<k; i++){",
		  "    nume *= (n-i);",
		  "    deno *= (i+1);",
		  "    ll g = gcd(nume, deno);",
		  "    nume /= g;",
		  "    deno /= g;",
		  "  }",
		  "  return (ll)(nume/deno);",
		  "}",
		  ""
		],
		"description": ""
	  },

	  "nck_mod_p": {
		"prefix": "kenchon_nck",
		"body": [
		  "const int MAX = 510000;",
		  "const int MOD = 1000000007;",
		  "",
		  "long long fac[MAX], finv[MAX], inv[MAX];",
		  "",
		  "// テーブルを作る前処理",
		  "void COMinit() {",
		  "    fac[0] = fac[1] = 1;",
		  "    finv[0] = finv[1] = 1;",
		  "    inv[1] = 1;",
		  "    for (int i = 2; i < MAX; i++){",
		  "        fac[i] = fac[i - 1] * i % MOD;",
		  "        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "        finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "    }",
		  "}",
		  "",
		  "// 二項係数計算",
		  "long long COM(int n, int k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "}",
		  ""
		],
		"description": "mod nck"
	  },

	  "nck_mod": {
		"prefix": "nck_mod",
		"body": [
		  "ll mod = 1e9+7;",
		  "#define NMAX 200010",
		  "ll fac[NMAX];",
		  "ll inv[NMAX];",
		  "",
		  "ll mod_pow(ll a, ll n, ll mod){",
		  "    ll ret = 1;",
		  "    while(n > 0){",
		  "        if(n & 1) ret = (ret*(a % mod))%mod;",
		  "        a = ((a%mod)*(a%mod)) % mod;",
		  "        n = n >> 1;",
		  "    }",
		  "    return ret;",
		  "}",
		  "",
		  "ll mod_inv(ll a, ll mod){",
		  "    return mod_pow(a, mod-2, mod);",
		  "}",
		  "",
		  "void mae_nck(){",
		  "    fac[1] = 1;",
		  "    inv[1] = 1;",
		  "    for(ll i = 2; i < NMAX; i++){",
		  "        fac[i] = (fac[i-1] * i)%mod;",
		  "        inv[i] = (inv[i-1] * mod_inv(i, mod))%mod;",
		  "    }",
		  "}",
		  "",
		  "ll mod_nck(ll n, ll k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    if(k == 0 || k == n) return 1;",
		  "    ll ret = ((fac[n] * inv[k])%mod * inv[n-k])%mod;",
		  "    return ret;",
		  "}"
		],
		"description": "nck mod p"
	  },
	  "union find": {
		"prefix": "union_find_snippets",
		"body": [
		  "struct union_find {",
		  "public:",
		  "    union_find(int _n) : n(_n), group(_n) {",
		  "        parent.resize(n);",
		  "        nums.resize(n, 1);",
		  "        iota(parent.begin(), parent.end(), 0);",
		  "    }",
		  "    int root(int x) {",
		  "        if(parent[x] == x) return x;",
		  "        parent[x] = root(parent[x]);",
		  "        return parent[x];",
		  "    }",
		  "    // Merge y to x",
		  "    void merge(int x, int y) {",
		  "        int rx = root(x);",
		  "        int ry = root(y);",
		  "        if(rx != ry){",
		  "            group--;",
		  "            parent[ry] = rx;",
		  "            nums[rx] += nums[ry];",
		  "        }",
		  "    }",
		  "    bool same(int x, int y) {",
		  "        return (root(x) == root(y));",
		  "    }",
		  "    int size() {",
		  "        return group;",
		  "    }",
		  "    int size(int x) {",
		  "        return nums[root(x)];",
		  "    }",
		  "private:",
		  "    int n, group;",
		  "    std::vector<int> parent;",
		  "    std::vector<int> nums;",
		  "};  "
		],
		"description": ""
	  },

	  "map_factorize": {
		"prefix": "map_factorize",
		"body": [
		  "map<ll, ll> factorize(ll g){",
		  "    map<ll, ll> ret;",
		  "    if(g == 1){",
		  "        ret[1]++;",
		  "        return ret;",
		  "    }",
		  "    ll d = 2;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            ret[d]++;",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                ret[d]++;",
		  "                g /= d;",
		  "            }",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret[g]++;",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "dist": {
		"prefix": "dist_line_point",
		"body": [
		  "double dist(double x1, double y1, double x2, double y2, double p, double q){",
		  "    double a = y2 - y1;",
		  "    double b = x2 - x1;",
		  "    double c = -x1*a + y1*b;",
		  "    double d = abs(a*p - b*q + c)/sqrt(a*a+b*b);",
		  "    return d;",
		  "}"
		],
		"description": "Calcurate the distance between a line and a point. The line is expressed by two points that are on the line."
	  },
	  "min_dga": {
		"prefix": "min_dag",
		"body": [
		  "/*",
		  "使い方",
		  "1. 以下をグローバル宣言",
		  "- ワーシャルフロイド用の2点間距離配列 d",
		  "- グラフ G",
		  "- 最短経路のみを持つDAG DAG",
		  "",
		  "2. dとGを初期化",
		  "- NOTE： 1-indexed",
		  "",
		  "3. make_dag(始点，終点，頂点数);",
		  "",
		  "たぶん O(N^3)",
		  "*/",
		  "",
		  "vector<vector<ll>> DAG, d, G;",
		  "",
		  "void make_dag(ll A, ll B, ll N){",
		  "    ",
		  "    //　ワーシャルフロイド",
		  "    rep(i, 1, N+1) d[i][i] = 0;",
		  "    rep(i, 1, N+1){",
		  "        rep(j, 1, N+1){",
		  "            rep(k, 1, N+1){",
		  "                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // 最短経路のみのDAG作成",
		  "    DAG.resize(N+1);",
		  "    queue<ll> que;",
		  "    vector<bool> seen(N+1, false);",
		  "    que.push(A);",
		  "    while(!que.empty()){",
		  "        auto t = que.front();",
		  "        que.pop();",
		  "        if(seen[t]) continue;",
		  "        seen[t] = true;",
		  "        for(auto g : G[t]){",
		  "            if(d[A][t] + 1 + d[g][B] == d[A][B]){",
		  "                DAG[t].push_back(g);",
		  "                que.push(g);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "warshall_floyed": {
		"prefix": "warshall_floyed_snippets",
		"body": [
		  "namespace wf {",
		  "    // There is no edge with negative cost",
		  "    template<class T>",
		  "    void warshallFloyed(std::vector<std::vector<T>> &d) {",
		  "        int n = d.size();",
		  "        for(int i = 0; i < n; i++) d[i][i] = 0;",
		  "        for(int i = 0; i < n; i++) {",
		  "            for(int j = 0; j < n; j++) {",
		  "                for(int k = 0; k < n; k++) {",
		  "                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    // There are edges with negative cost.",
		  "    // If graph has negative cycle, return false",
		  "    template<class T>",
		  "    bool warshallFloyedNeg(std::vector<std::vector<T>> &d, T inf) {",
		  "        bool res = true;",
		  "        int n = d.size();",
		  "        auto chmin = [&](T &a, T b) {",
		  "            if(a == inf) a = b;",
		  "            else if(b == inf) ;",
		  "            else a = std::min(a, b);",
		  "        };",
		  "        auto addinf = [&](T a, T b) -> T {",
		  "            if(a == inf || b == inf) return inf;",
		  "            else return a + b;",
		  "        };",
		  "        for(int i = 0; i < n; i++) chmin(d[i][i], 0);",
		  "        for(int i = 0; i < n; i++) {",
		  "            for(int j = 0; j < n; j++) {",
		  "                for(int k = 0; k < n; k++) {",
		  "                    chmin(d[j][k], addinf(d[j][i], d[i][k]));",
		  "                }",
		  "            }",
		  "        }",
		  "        for(int i = 0; i < n; i++) if(d[i][i] < 0) res = false;",
		  "        return res;",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "plus_templates": {
		"prefix": "plustemplate",
		"body": [
		  "#define VL vector<ll>",
		  "#define VS vector<string>",
		  "#define VB vector<bool>",
		  "#define VP vector<pair<ll,ll>>",
		  "#define VVL vector<vector<ll>>",
		  "#define VVP vector<vector<pair<ll,ll>>>",
		  "#define PL pair<ll,ll>",
		  "#define ALL(v) (v).begin(), (v).end()",
		  "ll d1[4] = {1, -1, 0, 0};",
		  "ll d2[4] = {0, 0, 1, -1};"
		],
		"description": ""
	  },
	  "yakusu": {
		"prefix": "yakusu_snippets",
		"body": [
		  "std::vector<long long> yakusu(long long n){",
		  "    std::vector<long long> ret;",
		  "    for(long long i = 1; i * i <= n; i++){",
		  "        if(n % i != 0) continue;",
		  "        ret.push_back(i);",
		  "        if(i*i != n) ret.push_back(n/i);",
		  "    }",
		  "    sort(ret.begin(), ret.end());",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "prime_factorize": {
		"prefix": "prime_factorize_snippets",
		"body": [
		  "std::vector<std::pair<long long, long long>> prime_factorize(long long n){",
		  "    std::vector<std::pair<long long, long long>> ret;",
		  "    for(long long a = 2; a * a <= n; a++){",
		  "        if(n % a != 0) continue;",
		  "        long long ex = 0;",
		  "        while(n % a == 0){",
		  "            ex++;",
		  "            n /= a;",
		  "        }",
		  "        ret.push_back({a, ex});",
		  "    }",
		  "    if(n != 1) ret.push_back({n, 1});",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "Z-algorithm": {
		"prefix": "Zalgo",
		"body": [
		  "vector<ll> Zalgo(string S){",
		  "    ll N = S.size();",
		  "    vector<ll> ret(N);",
		  "    ret[0] = N;",
		  "    ll i = 1, j = 0;",
		  "    while(i < N){",
		  "        while(i + j < N && S[j] == S[i+j]) j++;",
		  "        ret[i] = j;",
		  "        if(j == 0){",
		  "            i++;",
		  "            continue;",
		  "        }",
		  "        ll k = 1;",
		  "        while(i + k < N && k + ret[k] < j){",
		  "            ret[i+k] = ret[k];",
		  "            k++;",
		  "        }",
		  "        i += k;",
		  "        j -= k;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "PI": {
		"prefix": "PI",
		"body": [
		  "constexpr double PI=3.14159265358979323846;"
		],
		"description": ""
	  },
	  "fenwick tree": {
		"prefix": "BIT",
		"body": [
		  "#define FENWICK_NMAX 200010",
		  "struct fenwick_tree{",
		  "    ll N;",
		  "    ll bit[FENWICK_NMAX];",
		  "    fenwick_tree(ll n){",
		  "        N = n;",
		  "        for(ll x = 1; x <= N; x++){",
		  "            bit[x] = 0;",
		  "        }",
		  "    }",
		  "    void add(ll a, ll w){",
		  "        for(ll x = a; x <= N; x += x & -x){",
		  "            bit[x] += w;",
		  "        }",
		  "    }",
		  "    ll sum(ll a){",
		  "        ll ret = 0;",
		  "        for(ll x = a; x > 0; x -= x & -x){",
		  "            ret += bit[x];",
		  "        }",
		  "        return ret;",
		  "    }",
		  "};"
		],
		"description": "fenwick tree"
	  },
	  "bellman_ford_snippets": {
		"prefix": "bellman_ford_snippets",
		"body": [
		  "namespace bellman {",
		  "",
		  "    const ll inf = 1LL<<60;",
		  "",
		  "    typedef struct EdgeInfo{",
		  "        ll from;",
		  "        ll to;",
		  "        ll cost;",
		  "        EdgeInfo() {};",
		  "        EdgeInfo(ll _from, ll _to, ll _cost) : from(_from), to(_to), cost(_cost) {};",
		  "    } edge;",
		  "",
		  "    vector<pair<ll,bool>> bellman_ford(ll n, vector<edge> E) {",
		  "        ",
		  "        ll m = E.size();",
		  "        vector<ll> d(n, inf);",
		  "        ",
		  "        // グラフ全体での負経路検出",
		  "        bool closed_loop = false;",
		  "",
		  "        ll srt = 0;",
		  "        d[srt] = 0;",
		  "        rep(i, 0, n){",
		  "            rep(j, 0, m){",
		  "                auto e = E[j];",
		  "                if(d[e.to] > d[e.from] + e.cost){",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    if(i == n-1){",
		  "                        closed_loop = true;",
		  "                        break;",
		  "                    }",
		  "                }",
		  "            }",
		  "            if(closed_loop) break;",
		  "        }",
		  "",
		  "        vector<pair<ll,bool>> res(n);",
		  "        rep(i, 0, n) res[i].first = d[i];",
		  "",
		  "        // 各頂点への経路中の負閉路検出",
		  "        vector<bool> neg(n, false);",
		  "",
		  "        rep(loop, 0, n) {",
		  "            rep(i, 0, m) {",
		  "                auto e = E[i];",
		  "                if(d[e.from] == inf) continue;",
		  "                if(d[e.to] > d[e.from] + e.cost) {",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    neg[e.to] = true;",
		  "                }",
		  "                if(neg[e.from]) neg[e.to] = true;",
		  "            }",
		  "        }",
		  "",
		  "        rep(i, 0, n) res[i].second = neg[i];",
		  "        return res;",
		  "    }",
		  "    // res.second == true のとき，答えは無限に小さくなりえる．",
		  "};"
		],
		"description": ""
	  },
	  "baisu": {
		"prefix": "baisu",
		"body": [
		  "// low以上high以下のbaseの倍数の数",
		  "ll baisu(ll base, ll low, ll high){",
		  "    ll bt = (low + base - 1) / base;",
		  "    ll up = high / base;",
		  "    return up - bt + 1;",
		  "}"
		],
		"description": ""
	  },
	  "RMQ": {
		"prefix": "RMQ",
		"body": [
		  "",
		  "template <typename T> struct RMQ{",
		  "    ",
		  "    const ll NMAX = 1 << 17; // 131072",
		  "    const ll LL_MAX = 1e18 + 20;",
		  "    ll n;",
		  "    vector<T> dat;",
		  "",
		  "    RMQ(ll _n){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "    }",
		  "",
		  "    RMQ(ll _n, T _ini_val){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "        for(ll i = 0; i < 2 * n - 1; i++) dat[i] = _ini_val;",
		  "    }",
		  "",
		  "    void update(ll k, T a){",
		  "        k += n - 1;",
		  "        dat[k] = a;",
		  "        while(k > 0){",
		  "            k = (k-1) / 2;",
		  "            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);",
		  "        }",
		  "    }",
		  "",
		  "    T query(ll a, ll b, ll k, ll l, ll r){",
		  "        // [a, b) の最小値を求める．",
		  "        // k := nodeの番号",
		  "        // kが[l, r)に対応している．",
		  "        // query(a, b, 0, 0, n)で外から呼ぶ",
		  "        ",
		  "        // [a, b)と[l，r)が交差しないケース",
		  "        if(r <= a || b <= l){",
		  "            return LL_MAX;",
		  "        }",
		  "",
		  "        if(a <= l && r <= b){",
		  "            // [a, b)を[l, r)含むケース",
		  "            return dat[k];",
		  "        }else{",
		  "            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);",
		  "            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);",
		  "            return min(vl, vr);",
		  "        }",
		  "    }",
		  "    ",
		  "    T query(ll a, ll b){",
		  "        return query(a, b, 0, 0, n);",
		  "    }",
		  "",
		  "};",
		  "/*",
		  "int main(){",
		  "    ll N, Q;",
		  "    cin >> N >> Q;",
		  "    RMQ<ll> sg(N, (1LL<<31) - 1);",
		  "    rep(q, 0, Q){",
		  "        ll comm, x, y;",
		  "        cin >> comm >> x >> y;",
		  "        if(comm == 0) sg.update(x, y);",
		  "        else cout << sg.query(x, y+1) << endl;",
		  "    }",
		  "    return 0;",
		  "}",
		  "*/"
		],
		"description": ""
	  },
	  "Segment_tree_kenchyon": {
		"prefix": "segmenttree",
		"body": [
		  "template<class Monoid> struct SegTree {",
		  "    using Func = function<Monoid(Monoid, Monoid)>;",
		  "    const Func F;",
		  "    const Monoid UNITY;",
		  "    int SIZE_R;",
		  "    vector<Monoid> dat;",
		  "    ",
		  "    SegTree(int n, const Func f, const Monoid &unity): F(f), UNITY(unity) { init(n); }",
		  "    void init(int n) {",
		  "        SIZE_R = 1;",
		  "        while (SIZE_R < n) SIZE_R *= 2;",
		  "        dat.assign(SIZE_R * 2, UNITY);",
		  "    }",
		  "    ",
		  "    /* set, a is 0-indexed */",
		  "    void set(int a, const Monoid &v) { dat[a + SIZE_R] = v; }",
		  "    void build() {",
		  "        for (int k = SIZE_R - 1; k > 0; --k)",
		  "            dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* update, a is 0-indexed */",
		  "    void update(int a, const Monoid &v) {",
		  "        int k = a + SIZE_R;",
		  "        dat[k] = v;",
		  "        while (k >>= 1) dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* get {min-value, min-index}, a and b are 0-indexed */",
		  "    Monoid get(int a, int b) {",
		  "        Monoid vleft = UNITY, vright = UNITY;",
		  "        for (int left = a + SIZE_R, right = b + SIZE_R; left < right; left >>= 1, right >>= 1) {",
		  "            if (left & 1) vleft = F(vleft, dat[left++]);",
		  "            if (right & 1) vright = F(dat[--right], vright);",
		  "        }                                                                                                              ",
		  "        return F(vleft, vright);",
		  "    }",
		  "    inline Monoid operator [] (int a) { return dat[a + SIZE_R]; }",
		  "    ",
		  "    /* debug */",
		  "    void print() {",
		  "        for (int i = 0; i < SIZE_R; ++i) {",
		  "            cout << (*this)[i];",
		  "            if (i != SIZE_R-1) cout << \",\";",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "line_cross_check": {
		"prefix": "line_cross",
		"body": [
		  "typedef struct Point_Coordinates {",
		  "    double x, y;",
		  "} point;",
		  "",
		  "// 線分ab, cdが交差する場合True",
		  "// 端点が他方の線分上にある場合もTrue",
		  "bool judge(point a, point b, point c, point d){",
		  "    double s, t;",
		  "    s = (a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x);",
		  "    t = (a.x - b.x) * (a.y - d.y) - (a.y - b.y) * (a.x - d.x);",
		  "    if (s * t >= 0) return false;",
		  "",
		  "    s = (c.x - d.x) * (c.y - a.y) - (c.y - d.y) * (c.x - a.x);",
		  "    t = (c.x - d.x) * (c.y - b.y) - (c.y - d.y) * (c.x - b.x);",
		  "    if (s * t >= 0) return false;",
		  "    ",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "LCS": {
		"prefix": "LCS",
		"body": [
		  "string LCS(string s, string t){",
		  "    ll ns = s.size();",
		  "    ll nt = t.size();",
		  "    vector< vector<ll> > dp(ns+1, vector<ll> (nt+1, 0));",
		  "    // initilaize",
		  "    rep(i, 0, ns){",
		  "        if(s[i] == t[0]) dp[i][0] = 1;",
		  "    }",
		  "    rep(i, 0, nt){",
		  "        if(s[0] == t[i]) dp[0][i] = 1;",
		  "    }",
		  "    // build DP table",
		  "    rep(i, 1, ns){",
		  "        rep(j, 1, nt){",
		  "            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);",
		  "            if(s[i] == t[j]){",
		  "                dp[i][j] = dp[i-1][j-1] + 1;",
		  "            }",
		  "        }",
		  "    }",
		  "    // make LCS",
		  "    string ret;",
		  "    ll i = ns-1, j = nt-1;",
		  "    while(i >= 0 && j >= 0){",
		  "        if(s[i] == t[j]){",
		  "            ret.push_back(s[i]);",
		  "            i--; j--;",
		  "        }else{",
		  "            if(j == 0) i--;",
		  "            else if(i == 0) j--;",
		  "            else if(dp[i-1][j] > dp[i][j-1]) i--;",
		  "            else j--;",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "2bugraph": {
		"prefix": "2bugraph",
		"body": [
		  "// 2部グラフの判定",
		  "// 使い方：colorを-1で初期化してください．",
		  "// 注意：連結かどうかに気をつけてください．",
		  "// 参考：https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-3-%E4%BA%8C%E9%83%A8%E3%82%B0%E3%83%A9%E3%83%95%E5%88%A4%E5%AE%9A",
		  "vector<ll> color;",
		  "bool is_2bu_graph(vector< vector<ll> >& G, ll now, ll col) {",
		  "    color[now] = col;",
		  "    for(auto g : G[now]) {",
		  "        if(color[g] != -1) {",
		  "            if(color[g] == col) return false;",
		  "            else continue;",
		  "        } else {",
		  "            if(!is_2bu_graph(G, g, 1-col)) return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "centroid": {
		"prefix": "centroid_snippets",
		"body": [
		  "namespace centroid {",
		  "    ",
		  "    using ll = long long;",
		  "    ",
		  "    ll dfs(std::vector<std::vector<ll>>& G, std::vector<ll>& max_subtree, ll cur, ll par, ll n) {",
		  "        ll mx = 0, sum = 0;",
		  "        for(auto g : G[cur]) {",
		  "            if(g == par) continue;",
		  "            ll tmp = dfs(G, max_subtree, g, cur, n);",
		  "            sum += tmp;",
		  "            mx = std::max(mx, tmp);",
		  "        }",
		  "        mx = std::max(mx, n - sum - 1);",
		  "        max_subtree[cur] = mx;",
		  "        return sum + 1;",
		  "    }",
		  "",
		  "    std::vector<ll> find(std::vector<std::vector<ll>>& G) {",
		  "        ll n = G.size();",
		  "        std::vector<ll> max_subtree(n, 0);",
		  "        dfs(G, max_subtree, 0, -1, n);",
		  "        std::vector<ll> res;",
		  "        ll mn = *min_element(max_subtree.begin(), max_subtree.end());",
		  "        for(ll i = 0; i < n; i++) if(max_subtree[i] == mn) res.push_back(i);",
		  "        return res;",
		  "    }",
		  "",
		  "}",
		  "",
		  ""
		],
		"description": ""
	  },
	  "compare string": {
		"prefix": "string_comp",
		"body": [
		  "// a >= b ?",
		  "const string MININF = \"-\";",
		  "bool comp(string a, string b){",
		  "    if(b == MININF) return true;",
		  "    if(a == MININF) return false;",
		  "    if(a.size() > b.size()) return true;",
		  "    if(a.size() < b.size()) return false;",
		  "    rep(i, 0, a.size()){",
		  "        if(a[i] > b[i]) return true;",
		  "        if(a[i] < b[i]) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "kruskal": {
		"prefix": "kruskal_snippets",
		"body": [
		  "namespace kruskal {",
		  "",
		  "    using ll = long long;",
		  "    using pl = std::pair<ll, ll>;",
		  "    ",
		  "    struct union_find {",
		  "    public:",
		  "        union_find(int _n) : n(_n), group(_n) {",
		  "            parent.resize(n);",
		  "            nums.resize(n, 1);",
		  "            iota(parent.begin(), parent.end(), 0);",
		  "        }",
		  "        int root(int x) {",
		  "            if(parent[x] == x) return x;",
		  "            parent[x] = root(parent[x]);",
		  "            return parent[x];",
		  "        }",
		  "        // Merge y to x",
		  "        void merge(int x, int y) {",
		  "            int rx = root(x);",
		  "            int ry = root(y);",
		  "            if(rx != ry){",
		  "                group--;",
		  "                parent[ry] = rx;",
		  "                nums[rx] += nums[ry];",
		  "            }",
		  "        }",
		  "        bool same(int x, int y) {",
		  "            return (root(x) == root(y));",
		  "        }",
		  "        int size() {",
		  "            return group;",
		  "        }",
		  "        int size(int x) {",
		  "            return nums[root(x)];",
		  "        }",
		  "    private:",
		  "        int n, group;",
		  "        std::vector<int> parent;",
		  "        std::vector<int> nums;",
		  "    };  ",
		  "",
		  "    struct edge {",
		  "        ll v1, v2, cost, id;",
		  "    };",
		  "",
		  "    struct mst {",
		  "    public:",
		  "        mst(int _n) : n(_n), build_cost(-1) {}",
		  "        void add_edge(int v1, int v2, int cost) {",
		  "            edges.push_back(edge{v1, v2, cost, (ll)edges.size()});",
		  "        } ",
		  "        void add_edge(int v1, int v2, int cost, int id) {",
		  "            edges.push_back(edge{v1, v2, cost, id});",
		  "        }",
		  "        ll build() {",
		  "            union_find uf(n);",
		  "            ll cost = 0;",
		  "            auto copied_edges = edges;",
		  "            sort(copied_edges.begin(), copied_edges.end(), [](const auto& l, const auto& r) {",
		  "                return l.cost < r.cost;",
		  "            });",
		  "            for(auto e : copied_edges) {",
		  "                if(uf.same(e.v1, e.v2)) continue;",
		  "                uf.merge(e.v1, e.v2);",
		  "                cost += e.cost;",
		  "                used_edges.push_back(e.id);",
		  "            }",
		  "            build_cost = cost;",
		  "            return cost;",
		  "        }",
		  "        ll get_cost() {",
		  "            if(build_cost == -1) build();",
		  "            return build_cost;",
		  "        }",
		  "        std::vector<std::vector<pl>> get_tree() {",
		  "            if(build_cost == -1) build();",
		  "            std::vector<std::vector<pl>> G(n);",
		  "            for(auto e : used_edges) {",
		  "                G[edges[e].v1].push_back({edges[e].v2, edges[e].cost});",
		  "                G[edges[e].v2].push_back({edges[e].v1, edges[e].cost});",
		  "            }",
		  "            return G;",
		  "        }",
		  "        std::vector<ll> get_used_edges() {",
		  "            if(build_cost == -1) build();",
		  "            return used_edges;",
		  "        }",
		  "    private:",
		  "        int n; // # of verticies",
		  "        ll build_cost;",
		  "        std::vector<edge> edges;",
		  "        std::vector<ll> used_edges;",
		  "    };",
		  "",
		  "    mst make_mst(const std::vector<std::vector<pl>>& G) {",
		  "        int n = G.size();",
		  "        mst t(n);",
		  "        for(int i = 0; i < n; i++) {",
		  "            for(auto e : G[i]) {",
		  "                t.add_edge(i, e.first, e.second);",
		  "            }",
		  "        }",
		  "        return t;",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "run_length_encoding": {
		"prefix": "run_length_encoding_snippets",
		"body": [
		  "std::vector<std::pair<char, int>> run_length_encoding(const std::string& s) {",
		  "    std::vector<std::pair<char, int>> res;",
		  "    int n = s.size();",
		  "    char prev = -1;",
		  "    int cur = 1;",
		  "    for(int i = 0; i < n; i++) {",
		  "        if(prev == s[i]) cur++;",
		  "        else {",
		  "            if(prev != -1) res.push_back({prev, cur});",
		  "            prev = s[i];",
		  "            cur = 1;",
		  "        } ",
		  "    }",
		  "    res.push_back({prev, cur});",
		  "    return res;",
		  "}",
		  "",
		  "template<class T>",
		  "std::vector<std::pair<T, int>> run_length_encoding(const std::vector<T>& s){",
		  "    std::vector<std::pair<T, int>> res;",
		  "    int n = s.size();",
		  "    int prev = -1;",
		  "    int cur = 1;",
		  "    for(int i = 0; i < n; i++) {",
		  "        if(prev == s[i]) cur++;",
		  "        else {",
		  "            if(prev != -1) res.push_back({prev, cur});",
		  "            prev = s[i];",
		  "            cur = 1;",
		  "        } ",
		  "    }",
		  "    res.push_back({prev, cur});",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "dump_snippets": {
		"prefix": "dump_snippets",
		"body": [
		  "// For debug",
		  "// Ref: https://qiita.com/ysuzuki19/items/d89057d65284ba1a16ac",
		  "#define dump(var)  do{std::cerr << #var << \" : \";view(var);}while(0)",
		  "template<typename T> void view(T e){std::cerr << e << \"\\n\";}",
		  "template<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cerr << e << \" \"; } std::cerr << \"\\n\";}",
		  "template<typename T> void view(const std::vector<std::vector<T> >& vv){ std::cerr << \"\\n\"; for(const auto& v : vv){ view(v); } }",
		  "template<typename T> void dump_cout(const T& v) { for(long long i = 0; i < v.size(); i++) std::cout << v[i] << (i == v.size()-1 ? \"\\n\" : \" \"); }"
		],
		"description": ""
	  },
	  "set grep2vec": {
		"prefix": "set_grep",
		"body": [
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.begin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> grep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [grep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.begin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.rbegin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> rgrep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [rgrep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.rbegin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "str2dec": {
		"prefix": "str2dec_snippets",
		"body": [
		  "/*",
		  "オーバーフローには気を付けよう！",
		  "Inputs:",
		  "    string s        : string representing a decimal number, such as 123.4, 0.123, 123.",
		  "    int shift_size  : shift size, formally, this function return s * 10 ^ shift_size.",
		  "Output:",
		  "    Return s * 10 ^ shift_size as long long.",
		  "*/",
		  "long long str2dec(std::string s, int shift_size) {",
		  "    auto pos = s.find('.');",
		  "    auto pw = [](long long a, int p) -> long long {",
		  "        long long res = 1;",
		  "        for(int i = 0; i < p; i++) res *= a;",
		  "        return res;",
		  "    };",
		  "    if(pos == std::string::npos) return atoll(s.c_str()) * pw(10LL, shift_size); // If s is an integer",
		  "    long long res = atoll(s.substr(0, pos).c_str()) * pw(10LL, shift_size); ",
		  "    res += atoll(s.substr(pos+1, s.size()-pos-1).c_str()) * pw(10LL, shift_size - (s.size()-pos-1));",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "split": {
		"prefix": "split_snippets",
		"body": [
		  "// s.split(c) in python",
		  "std::vector<std::string> split(std::string s, char c){",
		  "    std::vector<std::string> res;",
		  "    s.push_back(c); // 番兵",
		  "    int n = s.size();",
		  "    std::string cur;",
		  "    for(int i = 0; i < n; i++) {",
		  "        if(s[i] == c) {",
		  "            res.push_back(cur);",
		  "            cur = \"\";",
		  "        } else {",
		  "            cur.push_back(s[i]);",
		  "        }",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "osa_k": {
		"prefix": "osa_k_snippets",
		"body": [
		  "namespace osa_k {",
		  "",
		  "    constexpr int max_size = 2020202; // 2 * 10^6",
		  "    ",
		  "    struct min_factor_table {",
		  "    public:",
		  "        min_factor_table() {",
		  "            min_factor.resize(max_size, 1);",
		  "            for(int i = 2; i < max_size; i++) {",
		  "                if(min_factor[i] != 1) continue;",
		  "                for(int j = i; j < max_size; j += i) {",
		  "                    if(min_factor[j] != 1) continue;",
		  "                    min_factor[j] = i;",
		  "                }",
		  "            }",
		  "        }",
		  "        std::vector<std::pair<int, int>> prime_factorize(int n) {",
		  "            assert(n < max_size);",
		  "            std::vector<std::pair<int, int>> res;",
		  "            while(n != 1) {",
		  "                int fact = min_factor[n];",
		  "                int count = 0;",
		  "                while(n % fact == 0) {",
		  "                    n /= fact;",
		  "                    count++;",
		  "                }",
		  "                res.emplace_back(fact, count);",
		  "            }",
		  "            sort(res.begin(), res.end());",
		  "            return res;",
		  "        }",
		  "        int mebious(int n) {",
		  "            assert(n < max_size);",
		  "            int num = 0;",
		  "            while(n != 1) {",
		  "                num++;",
		  "                int fact = min_factor[n];",
		  "                int count = 0;",
		  "                while(n % fact == 0) {",
		  "                    n /= fact;",
		  "                    count++;",
		  "                }",
		  "                if(count >= 2) return 0;",
		  "            }",
		  "            return (num % 2 == 0 ? 1 : -1);",
		  "        }",
		  "    private:",
		  "        std::vector<int> min_factor;",
		  "    } table;",
		  "",
		  "    std::vector<std::pair<int, int>> prime_factorize(int n) {",
		  "        return table.prime_factorize(n);",
		  "    } ",
		  "    int mebious(int n) {",
		  "        return table.mebious(n);",
		  "    }",
		  "    ",
		  "}"
		],
		"description": ""
	  },
	  "gradient": {
		"prefix": "gradient_snippets",
		"body": [
		  "std::pair<long long, long long> gradient(long long x1, long long y1, long long x2, long long y2) {",
		  "    long long dx = x2 - x1;",
		  "    long long dy = y2 - y1;",
		  "    if(dx < 0) {",
		  "        dx = -dx;",
		  "        dy = -dy;",
		  "    }",
		  "    if(dx == 0 && dy == 0) return {0, 0};",
		  "    else if(dx == 0) return {0, 1};",
		  "    else if(dy == 0) return {1, 0};",
		  "    long long g = std::gcd(abs(dx), abs(dy));",
		  "    dx /= g;",
		  "    dy /= g;",
		  "    return std::make_pair(dx, dy);",
		  "}"
		],
		"description": ""
	  },
	  "all same": {
		"prefix": "all_same",
		"body": [
		  "template<typename T> bool all_same(vector<T>& a) {",
		  "    if(a.empty()) return true;",
		  "    for(ll i = 0; i < a.size(); i++) if(a[i] != a[0]) return false;",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "modulo": {
		"prefix": "modulo_snippets",
		"body": [
		  "namespace modulo {",
		  "",
		  "    constexpr int max_size = 2020202; // 2 * 10^6",
		  "",
		  "    struct fact_table {",
		  "    public:",
		  "        fact_table() {",
		  "            fac.resize(max_size);",
		  "            ifac.resize(max_size);",
		  "            fac[0] = 1;",
		  "            fac[1] = 1;",
		  "            ifac[0] = 1;",
		  "            ifac[1] = 1;",
		  "            for(int i = 2; i < max_size; i++) {",
		  "                fac[i] = fac[i-1] * i;",
		  "                ifac[i] = ifac[i-1] / i;",
		  "            }",
		  "        }",
		  "        mint factor(int n) {",
		  "            assert(n < max_size);",
		  "            return fac[n];",
		  "        }",
		  "        mint ifactor(int n) {",
		  "            assert(n < max_size);",
		  "            return ifac[n];",
		  "        }",
		  "        mint comb(int n, int k) {",
		  "            if(n < k || n < 0 || k < 0) return 0;",
		  "            if(k == 0 || k == n) return 1;",
		  "            return fac[n] * ifac[k] * ifac[n-k];",
		  "        }",
		  "    private:",
		  "        std::vector<mint> fac, ifac;",
		  "    } table;",
		  "",
		  "    template<class T>",
		  "    mint fac(T n) {",
		  "        return table.factor(n);",
		  "    }",
		  "    template<class T>",
		  "    mint ifac(T n) {",
		  "        return table.ifactor(n);",
		  "    }",
		  "    template<class T>",
		  "    mint comb(T n, T k) {",
		  "        return table.comb(n, k);",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "lca": {
		"prefix": "lca_snippets",
		"body": [
		  "// Reference: https://algo-logic.info/lca/",
		  "template<class T = int>",
		  "struct lca {",
		  "public: ",
		  "    void dfs(std::vector<std::vector<T>> &G, int cur, int par, int d) {",
		  "        dist[cur] = d;",
		  "        parent[0][cur] = par;",
		  "        for(auto e : G[cur]) if(e != par) dfs(G, e, cur, d+1);",
		  "    }",
		  "    lca(std::vector<std::vector<T>> &G, int root = 0) {",
		  "        int n = G.size();",
		  "        int k = 1;",
		  "        while((1LL<<k) < n) k++;",
		  "        parent.resize(k+1, std::vector<int>(n, -1));",
		  "        dist.resize(n, -1);",
		  "        dfs(G, root, -1, 0);",
		  "        for(int i = 0; i < k; i++) {",
		  "            for(int j = 0; j < n; j++) {",
		  "                if(parent[i][j] == -1) parent[i+1][j] = -1;",
		  "                else parent[i+1][j] = parent[i][parent[i][j]];",
		  "            }",
		  "        }",
		  "    }",
		  "    int get_lca(int u, int v) {",
		  "        if(dist[u] < dist[v]) std::swap(u, v);",
		  "        int sz = parent.size();",
		  "        for(int i = 0; i < sz; i++) {",
		  "            int d = dist[u] - dist[v];",
		  "            if((d >> i) & 1LL) u = parent[i][u];",
		  "        }",
		  "        if(u == v) return u;",
		  "        for(int i = sz-1; i >= 0; i--) {",
		  "            if(parent[i][u] != parent[i][v]) {",
		  "                u = parent[i][u];",
		  "                v = parent[i][v];",
		  "            }",
		  "        }",
		  "        return parent[0][u];",
		  "    }",
		  "    int get_dist(int u, int v) {",
		  "        return dist[u] + dist[v] - 2 * dist[get_lca(u, v)];",
		  "    }",
		  "    /* If there is the node \"a\" on the path from u to v */",
		  "    bool is_on_path(int u, int v, int a) {",
		  "        return (get_dist(u, a) + get_dist(a, v) == get_dist(u, v));",
		  "    }",
		  "",
		  "private:",
		  "    std::vector<std::vector<int>> parent;",
		  "    std::vector<int> dist;",
		  "};"
		],
		"description": ""
	  },
	  "LIS": {
		"prefix": "lis_snippet",
		"body": [
		  "// けんちょんさんの",
		  "ll lis(vector<ll> &a) {",
		  "    constexpr ll inf = 1e18+13;",
		  "    ll n = a.size();",
		  "    vector<ll> dp(n, inf);",
		  "    for(ll i = 0; i < n; i++) {",
		  "        auto itr = lower_bound(dp.begin(), dp.end(), a[i]);",
		  "        *itr = a[i];",
		  "    }",
		  "    return lower_bound(dp.begin(), dp.end(), inf) - dp.begin();",
		  "}"
		],
		"description": ""
	  },
	  "atcoder_dsu": {
		"prefix": "atcoder_dsu",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/dsu>",
		  "using namespace atcoder;",
		  ""
		],
		"description": ""
	  },
	  "atcoder_bit": {
		"prefix": "atcoder_bit",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/fenwicktree>",
		  "using namespace atcoder;",
		  "template<typename T> void view(fenwick_tree<T>& bit, ll n) {",
		  "    rep(i, 0, n) cerr << bit.sum(i, i+1) << (i == n-1 ? \"\\n\" : \" \");",
		  "}",
		  "template<typename T> ll ith_element(fenwick_tree<T>&bit, ll ith, ll n) {",
		  "    ll le = 0, ri = n+1;",
		  "    while(ri - le > 1) {",
		  "        auto mi = (le + ri) / 2;",
		  "        auto tmp = bit.sum(0, mi);",
		  "        if(tmp < ith) le = mi;",
		  "        else ri = mi;",
		  "    }",
		  "    return ri-1;",
		  "}"
		],
		"description": ""
	  },
	  "atcoder_modint": {
		"prefix": "atcoder_modint",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/modint>",
		  "using namespace atcoder;",
		  "using mint = modint1000000007;",
		  "//using mint = modint998244353;"
		],
		"description": ""
	  },
	  "bubble_sort_count_snippets": {
		"prefix": "bubble_sort_count_snippets",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/fenwicktree>",
		  "using namespace atcoder;",
		  "",
		  "//https://misteer.hatenablog.com/entry/ARC088-E",
		  "ll bubble_count(string from, string to) {",
		  "    assert(from.size() == to.size());",
		  "    ll n = from.size();",
		  "    vector<queue<ll>> que(26);",
		  "    rep(i, 0, n) que[from[i]-'a'].push(i);",
		  "    vector<ll> idx(n);",
		  "    rep(i, 0, n) {",
		  "        idx[i] = que[to[i]-'a'].front();",
		  "        que[to[i]-'a'].pop();",
		  "    }",
		  "    fenwick_tree<ll> t(n+1);",
		  "    ll res = 0;",
		  "    rep(i, 0, n) {",
		  "        res += t.sum(idx[i], n);",
		  "        t.add(idx[i], 1);",
		  "    }",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "string_add": {
		"prefix": "string_add",
		"body": [
		  "string add(string a, string b) {",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    ll n = max(a.size(), b.size());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    string res;",
		  "    ll age = 0;",
		  "    rep(i, 0, n) {",
		  "        ll cur = age + (a[i] - '0') + (b[i] - '0');",
		  "        res.push_back(cur % 10 + '0');",
		  "        age = cur / 10;",
		  "    }",
		  "    if(age) res.push_back('1');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "tree_diameter": {
		"prefix": "tree_diameter_snippets",
		"body": [
		  "namespace tree_diameter {",
		  "    ",
		  "    using ll = long long;",
		  "    using pl = std::pair<ll, ll>;",
		  "",
		  "    pl dfs(const std::vector<std::vector<pl>>& G, ll cur, ll par) {",
		  "        pl res = {0, cur};",
		  "        for(auto [to, cost] : G[cur]) {",
		  "            if(to == par) continue;",
		  "            auto tmp = dfs(G, to, cur);",
		  "            if(res.first < tmp.first + cost) {",
		  "                res.first = tmp.first + cost;",
		  "                res.second = tmp.second;",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    ll len(const std::vector<std::vector<pl>>& G) {",
		  "        auto [a, x] = dfs(G, 0, -1);",
		  "        auto [b, y] = dfs(G, x, -1);",
		  "        return b;",
		  "    }",
		  "",
		  "    ll len(const std::vector<std::vector<ll>>& G) {",
		  "        std::vector<std::vector<pl>> dummyG(G.size());",
		  "        for(int i = 0; i < G.size(); i++) {",
		  "            for(const auto& e: G[i]) dummyG[i].push_back({e, 1});",
		  "        }",
		  "        return len(dummyG);",
		  "    }",
		  "",
		  "    std::vector<ll> path(const std::vector<std::vector<pl>>& G) {",
		  "        auto s = dfs(G, 0, -1).second;",
		  "        auto t = dfs(G, s, -1).second;",
		  "        std::vector<ll> res;",
		  "        auto dfs = [&](auto dfs, ll cur, ll par) -> bool {",
		  "            bool f = false;",
		  "            res.push_back(cur);",
		  "            if(cur == t) return true;",
		  "            for(auto [to, cost] : G[cur]) {",
		  "                if(to == par) continue;",
		  "                if(dfs(dfs, to, cur)) {",
		  "                    f = true;",
		  "                    break;",
		  "                }",
		  "            }",
		  "            if(!f) res.pop_back();",
		  "            return f;",
		  "        };",
		  "        dfs(dfs, s, -1);",
		  "        return res;",
		  "    }",
		  "",
		  "    std::vector<ll> path(const std::vector<std::vector<ll>>& G) {",
		  "        std::vector<std::vector<pl>> dummyG(G.size());",
		  "        for(int i = 0; i < G.size(); i++) {",
		  "            for(const auto& e: G[i]) dummyG[i].push_back({e, 1});",
		  "        }",
		  "        return path(dummyG);",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "pow_snippets": {
		"prefix": "pow_snippets",
		"body": [
		  "ll pow(ll a, ll p) {",
		  "    ll res = 1;",
		  "    rep(i, 0, p) res *= a;",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "saisyo_hougan_en_min_ball_minball": {
		"prefix": "saisyo_hougan_en_min_ball_minball",
		"body": [
		  "",
		  "// https://tubo28.me/compprog/algorithm/minball/",
		  "",
		  "using ld = double;",
		  "using P = complex<ld>;",
		  "using G = vector<P>;",
		  "const ld pi = acos(-1);",
		  "const ld eps = 1e-10;",
		  "const ld inf = 1e12;",
		  "",
		  "ld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }",
		  "ld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }",
		  "",
		  "template <class iter>",
		  "std::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {",
		  "    const int n = right - left;",
		  "",
		  "    assert(n >= 1);",
		  "    if (n == 1) {",
		  "        return {*left, ld(0)};",
		  "    }",
		  "",
		  "    std::mt19937 mt(seed);",
		  "    std::shuffle(left, right, mt);",
		  "    // std::random_shuffle(left, right); // simple but deprecated",
		  "",
		  "    iter ps = left;",
		  "    using circle = std::pair<P, ld>;",
		  "",
		  "    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {",
		  "        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),",
		  "           S = cross(b - a, c - a);",
		  "        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);",
		  "        ld r2 = std::norm(p - a);",
		  "        return {p, r2};",
		  "    };",
		  "",
		  "    auto make_circle_2 = [](const P &a, const P &b) -> circle {",
		  "        P c = (a + b) / (ld)2;",
		  "        ld r2 = std::norm(a - c);",
		  "        return {c, r2};",
		  "    };",
		  "",
		  "    auto in_circle = [](const P &a, const circle &c) -> bool {",
		  "        return std::norm(a - c.first) <= c.second + eps;",
		  "    };",
		  "",
		  "    circle c = make_circle_2(ps[0], ps[1]);",
		  "",
		  "    // MiniDisc",
		  "    for (int i = 2; i < n; ++i) {",
		  "        if (!in_circle(ps[i], c)) {",
		  "            // MiniDiscWithPoint",
		  "            c = make_circle_2(ps[0], ps[i]);",
		  "            for (int j = 1; j < i; ++j) {",
		  "                if (!in_circle(ps[j], c)) {",
		  "                    // MiniDiscWith2Points",
		  "                    c = make_circle_2(ps[i], ps[j]);",
		  "                    for (int k = 0; k < j; ++k) {",
		  "                        if (!in_circle(ps[k], c)) {",
		  "                            c = make_circle_3(ps[i], ps[j], ps[k]);",
		  "                        }",
		  "                    }",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    return c;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "string_sub": {
		"prefix": "string_sub",
		"body": [
		  "string sub(string a, string b) {",
		  "    ll n = max(a.size(), b.size());",
		  "    assert(a.size() > b.size() || a >= b);",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    string res;",
		  "    ll age = 0;",
		  "    rep(i, 0, n) {",
		  "        if(a[i] < '0' || a[i] < b[i]) {",
		  "            assert(i != n-1);",
		  "            a[i] += 10;",
		  "            a[i+1] -= 1;",
		  "        }",
		  "        ll cur = (a[i] - b[i]) + '0';",
		  "        res.push_back(cur);",
		  "    }",
		  "    while(!res.empty()) {",
		  "        if(res.back() == '0') res.pop_back();",
		  "        else break;",
		  "    }",
		  "    if(res.empty()) res.push_back('0');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}"
		],
		"description": ""
	},
	"nijigen_2jigen_ruisekiwa_acc": {
		"prefix": "nijigen_2jigen_ruisekiwa_acc",
		"body": [
		  "// https://ei1333.github.io/algorithm/cumulative-sum2d.html",
		  "// sx, sy を含み，gx, gy を含まない",
		  "template< class T >",
		  "struct CumulativeSum2D",
		  "{",
		  "  vector< vector< T > > data;",
		  "",
		  "  CumulativeSum2D(int W, int H) : data(W + 1, vector< T >(H + 1, 0)) {}",
		  "",
		  "  void add(int x, int y, T z)",
		  "  {",
		  "    ++x, ++y;",
		  "    if(x >= data.size() || y >= data[0].size()) return;",
		  "    data[x][y] += z;",
		  "  }",
		  "",
		  "  void build()",
		  "  {",
		  "    for(int i = 1; i < data.size(); i++) {",
		  "      for(int j = 1; j < data[i].size(); j++) {",
		  "        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
		  "      }",
		  "    }",
		  "  }",
		  "",
		  "  T query(int sx, int sy, int gx, int gy)",
		  "  {",
		  "    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);",
		  "  }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "matrix": {
		"prefix": "matrix_snippets",
		"body": [
		  "namespace mm {",
		  " ",
		  "    template <class T> using matrix = std::vector<std::vector<T>>;",
		  "",
		  "    template <class T> ",
		  "    matrix<T> E(int n) {",
		  "        matrix<T> res(n, std::vector<T>(n, 0));",
		  "        for(int i = 0; i < n; i++) res[i][i] = 1;",
		  "        return res;",
		  "    }",
		  "",
		  "    template <class T> ",
		  "    matrix<T> matMul(matrix<T> a, matrix<T> b) {",
		  "        assert(a.size() && b.size());",
		  "        assert(a[0].size() == b.size());",
		  "        matrix<T> res(a.size(), std::vector<T>(b[0].size(), 0));",
		  "        for(int i = 0; i < a.size(); i++) {",
		  "            for(int j = 0; j < b[0].size(); j++) {",
		  "                for(int k = 0; k < b.size(); k++) {",
		  "                    res[i][j] += a[i][k] * b[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  " ",
		  "    template <class T> ",
		  "    std::vector<T> vecMul(matrix<T> a, std::vector<T> b) {",
		  "        assert(a.size() && b.size());",
		  "        assert(a[0].size() == b.size());",
		  "        std::vector<T> res(b.size(), 0);",
		  "        for(int i = 0; i < a.size(); i++) {",
		  "            for(int j = 0; j < b.size(); j++) {",
		  "                res[i] += a[i][j] * b[j];",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    template <class T> ",
		  "    matrix<T> matPow(matrix<T> a, long long p) {",
		  "        assert(a.size() && a.size() == a[0].size());",
		  "        matrix<T> res(a.size(), std::vector<T>(a.size(), 0));",
		  "        for(int i = 0; i < a.size(); i++) res[i][i] = 1;",
		  "        while(p) {",
		  "            if(p & 1) res = matMul(res, a);",
		  "            a = matMul(a, a);",
		  "            p /= 2;",
		  "        }",
		  "        return res;",
		  "    }",
		  " ",
		  "}"
		],
		"description": ""
	  },
	  "matrixPow": {
		"prefix": "matrixPow",
		"body": [
		  "namespace mat {",
		  " ",
		  "    template <class T> using matrix = vector<vector<T>>;",
		  " ",
		  "    template <class T> ",
		  "    matrix<T> matMul(matrix<T> a, matrix<T> b) {",
		  "        assert(a.size() && b.size());",
		  "        assert(a.size() == b[0].size() && a[0].size() == b.size());",
		  "        matrix<T> res(a.size(), vector<T>(b.size(), 0));",
		  "        rep(i, 0, a.size()) {",
		  "            rep(j, 0, b.size()) {",
		  "                rep(k, 0, b.size()) {",
		  "                    res[i][j] += a[i][k] * b[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  " ",
		  "    template <class T> ",
		  "    matrix<T> matPow(matrix<T> a, ll p) {",
		  "        assert(a.size() && a.size() == a[0].size());",
		  "        matrix<T> res(a.size(), vector<T>(a.size(), 0));",
		  "        rep(i, 0, a.size()) res[i][i] = 1;",
		  "        while(p) {",
		  "            if(p & 1) res = matMul(res, a);",
		  "            a = matMul(a, a);",
		  "            p /= 2;",
		  "        }",
		  "        return res;",
		  "    }",
		  " ",
		  "}"
		],
		"description": ""
	  },
	  "normal_comb": {
		"prefix": "normal_comb_snippets",
		"body": [
		  "long long comb(int n, int k) {",
		  "    if(n < k || n < 0 || k < 0) return 0;",
		  "    if(k == 0 || k == n) return 1;",
		  "    long long res = 1;",
		  "    for(int v = 1; v <= k; v++) {",
		  "        res *= (n + 1 - v);",
		  "        res /= v;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "ofop": {
		"prefix": "ofop_snippets",
		"body": [
		  "constexpr long long nmax = 1000000000000000000; // 10^18",
		  "",
		  "// nmaxより大きくなるとき, nmax+1を返す",
		  "long long ofpow(long long a, long long p) {",
		  "    if(a > nmax) return nmax + 1;",
		  "    if(a == 0) return 0;",
		  "    long long res = 1;",
		  "    for(int i = 0; i < p; i++) {",
		  "        if(nmax / a < res) return nmax + 1;",
		  "        res *= a;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "// nmaxより大きくなるとき, nmax+1を返す",
		  "long long ofmul(long long a, long long b) {",
		  "    if(a > nmax || b > nmax) return nmax + 1;",
		  "    if(a == 0 || b == 0) return 0;",
		  "    if(nmax / a < b) return nmax + 1;",
		  "    return a * b;",
		  "}"
		],
		"description": ""
	  },
	  "largestRectangle": {
		"prefix": "largest_rectangle_snippets",
		"body": [
		  "template <class T> ",
		  "T largestRectangle(vector<T> a) {",
		  "    a.push_back(0);",
		  "    int n = a.size();",
		  "    stack<int> st;",
		  "    vector<T> left(n);",
		  "    ll res = 0;",
		  "    rep(i, 0, n) {",
		  "        while(!st.empty() && a[st.top()] >= a[i]) {",
		  "            res = max(res, 1LL * (i - left[st.top()] - 1) * a[st.top()]);",
		  "            st.pop();",
		  "        }",
		  "        left[i] = st.empty() ? -1 : st.top();",
		  "        st.push(i);",
		  "    }",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "poly": {
		"prefix": "poly_snippets",
		"body": [
		  "template<class T>",
		  "struct poly {",
		  "    int n;",
		  "    vector<T> v;",
		  "    poly(int n = 0) : n(n), v(vector<T>(n, 0)) {}",
		  "    poly(initializer_list<T> init) : v(init.begin(), init.end()), n(init.end() - init.begin()) {}",
		  "    int size() const { return n; }",
		  "    T& operator[] (const int& i) { return v[i]; }",
		  "    const T& operator[] (const int& i) const { return v[i]; }",
		  "    void format() {",
		  "        for(ll i = n-1; i >= 0; i--) if(v[i] != 0) { ",
		  "            v = vector<T>(v.begin(), v.begin()+i+1);",
		  "            n = i+1; return;",
		  "        }",
		  "        v.clear(); n = 0;",
		  "    }",
		  "};",
		  "template<class T> ",
		  "poly<T> operator+(const poly<T>& t1, const poly<T> &t2) {",
		  "    int mx = max(t1.size(), t2.size());",
		  "    poly<T> res(mx);",
		  "    rep(i, 0, mx) {",
		  "        if(i < t1.size()) res[i] += t1[i];",
		  "        if(i < t2.size()) res[i] += t2[i];",
		  "    }",
		  "    return res;",
		  "}",
		  "template<class T> ",
		  "poly<T> operator-(const poly<T>& t1, const poly<T> &t2) {",
		  "    int mx = max(t1.size(), t2.size());",
		  "    poly<T> res(mx);",
		  "    rep(i, 0, mx) {",
		  "        if(i < t1.size()) res[i] += t1[i];",
		  "        if(i < t2.size()) res[i] -= t2[i];",
		  "    }",
		  "    return res;",
		  "}",
		  "template<class T> ",
		  "poly<T> operator*(const poly<T>& t1, const poly<T>& t2) {",
		  "    int mx = t1.size() + t2.size() - 1;",
		  "    poly<T> res(mx);",
		  "    rep(i, 0, t1.size()) {",
		  "        rep(j, 0, t2.size()) {",
		  "            res[i+j] += t1[i] * t2[j];",
		  "        }",
		  "    }    ",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "biop": {
		"prefix": "biop_snippets",
		"body": [
		  "std::string add(std::string a, std::string b) {",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    int n = std::max(a.size(), b.size());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    std::string res;",
		  "    int age = 0;",
		  "    for(int i = 0; i < n; i++) {",
		  "        int cur = age + (a[i] - '0') + (b[i] - '0');",
		  "        res.push_back(cur % 10 + '0');",
		  "        age = cur / 10;",
		  "    }",
		  "    if(age) res.push_back('1');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}",
		  "",
		  "std::string sub(std::string a, std::string b) {",
		  "    int n = std::max(a.size(), b.size());",
		  "    assert(a.size() > b.size() || a >= b);",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    std::string res;",
		  "    int age = 0;",
		  "    for(int i = 0; i < n; i++) {",
		  "        if(a[i] < '0' || a[i] < b[i]) {",
		  "            assert(i != n-1);",
		  "            a[i] += 10;",
		  "            a[i+1] -= 1;",
		  "        }",
		  "        int cur = (a[i] - b[i]) + '0';",
		  "        res.push_back(cur);",
		  "    }",
		  "    while(!res.empty()) {",
		  "        if(res.back() == '0') res.pop_back();",
		  "        else break;",
		  "    }",
		  "    if(res.empty()) res.push_back('0');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}",
		  "",
		  "// a >= b ?",
		  "bool comp(std::string a, std::string b) {",
		  "    if(a.size() > b.size()) return true;",
		  "    if(a.size() < b.size()) return false;",
		  "    for(int i = 0; i < a.size(); i++) {",
		  "        if(a[i] > b[i]) return true;",
		  "        if(a[i] < b[i]) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "rotate": {
		"prefix": "rotate_snippets",
		"body": [
		  "// Requirements:",
		  "// - `v` must be matrix.",
		  "template <class T> ",
		  "void rotate(std::vector<T>& v) {",
		  "    int h = v.size(), w = v[0].size();",
		  "    std::vector<T> res(w, T(h, '.'));",
		  "    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) {",
		  "        res[j][h-1-i] = v[i][j];",
		  "    }",
		  "    v = res;",
		  "}",
		  "",
		  "template<class T>",
		  "void print(std::vector<T> v) {",
		  "    for(int i = 0; i < v.size(); i++) {",
		  "        for(int j = 0; j < v[i].size(); j++) {",
		  "            std::cout << v[i][j] << (j == v[i].size()-1 ? \"\\n\" : \" \");",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "max_independent_set": {
		"prefix": "max_independent_set_snippets",
		"body": [
		  "// - Reference: http://kurkur.hatenablog.com/entry/2018/02/08/022629",
		  "// - 自己ループははじいてください．",
		  "// - 重複辺もはじいてください．",
		  "std::vector<int> max_independent_set(const std::vector<std::vector<int>> &G) {",
		  "    int n = G.size();",
		  "    int n1 = n/2, n2 = n-n1;",
		  "    std::vector<int> ok1(1<<n1, 1), ok2(1<<n2, 1), ok3(1<<n1, 0), dp(1<<n2, 0), rec(1<<n2);",
		  "    iota(rec.begin(), rec.end(), 0);",
		  "    for(int i = 0; i < n1; i++) for(auto u: G[i]) if(u < n1) ok1[(1<<i)|(1<<u)] = 0;",
		  "    for(int i = 0; i < (1<<n1); i++) if(!ok1[i]) for(int j = 0; j < n1; j++) ok1[i|(1<<j)] = 0;",
		  "    for(int i = n1; i < n; i++) for(auto u: G[i]) if(u >= n1) ok2[(1<<(i-n1))|(1<<(u-n1))] = 0;",
		  "    for(int i = 0; i < (1<<n2); i++) if(!ok2[i]) for(int j = 0; j < n2; j++) ok2[i|(1<<j)] = 0;",
		  "    for(int i = 0; i < (1<<n2); i++) if(ok2[i]) dp[i] = __builtin_popcount(i);",
		  "    for(int i = 0; i < (1<<n2); i++) for(int j = 0; j < n2; j++) {",
		  "        if(dp[i|(1<<j)] < dp[i]) {",
		  "            dp[i|(1<<j)] = dp[i];",
		  "            rec[i|(1<<j)] = rec[i];",
		  "        }",
		  "    }",
		  "    ok3[0] = (1<<n2) - 1;",
		  "    for(int i = 0; i < n1; i++) {",
		  "        ok3[1<<i] = (1<<n2) - 1;",
		  "        for(auto u: G[i]) if(u >= n1) ok3[1<<i] ^= (1<<(u-n1));",
		  "    }",
		  "    for(int i = 0; i < (1<<n1); i++) for(int j = 0; j < n1; j++) ok3[i|(1<<j)] = ok3[i] & ok3[1<<j];",
		  "    int count = 0, mask1 = 0, mask2 = 0;",
		  "    for(int i = 0; i < (1<<n1); i++) if(ok1[i]) {",
		  "        int tmp = __builtin_popcount(i) + dp[ok3[i]];",
		  "        if(count < tmp) {",
		  "            count = tmp;",
		  "            mask1 = i;",
		  "            mask2 = rec[ok3[i]];",
		  "        }",
		  "    }",
		  "    std::vector<int> vertices;",
		  "    for(int i = 0; i < n1; i++) if(mask1 & (1<<i)) vertices.push_back(i);",
		  "    for(int i = 0; i < n2; i++) if(mask2 & (1<<i)) vertices.push_back(i+n1);",
		  "    return vertices;",
		  "}"
		],
		"description": ""
	  },
	  "ofpow_snippets": {
		"prefix": "ofpow_snippets",
		"body": [
		  "constexpr ll nmax = 1e18+10;",
		  "ll ofpow(ll a, ll p) {",
		  "    ll res = 1;",
		  "    rep(i, 0, p) {",
		  "        if(nmax / a < res) return nmax+1;",
		  "        res *= a;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "isqrt": {
		"prefix": "isqrt_snippets",
		"body": [
		  "// return such maximum x that x^2 <= n ",
		  "long long isqrt(long long n) {",
		  "    long long res;",
		  "    double r = std::sqrt(n);",
		  "    for(long long i = std::max<long long>(0, r - 10); i < r + 10; i++) {",
		  "        if(i * i > n) {",
		  "            res = i - 1;",
		  "            break;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "range_mex_query": {
		"prefix": "mex_range_mex_query",
		"body": [
		  "// reference: https://kopricky.github.io/code/SegmentTrees/Basic/static_rangemexquery.html",
		  "class RangeMexQuery {",
		  "private:",
		  "    int n, m;",
		  "    vector<array<int, 3> > ptr;",
		  "    vector<int> arr, st;",
		  "    int update(const int prv, const int id, const int val, const int l, const int r){",
		  "        const int cur = (int)ptr.size();",
		  "        ptr.push_back({0, 0, id});",
		  "        if(r - l == 1) return cur;",
		  "        const int mid = (l + r) / 2;",
		  "        if(val < mid){",
		  "            const int res = update(ptr[prv][0], id, val, l, mid);",
		  "            ptr[cur][0] = res, ptr[cur][1] = ptr[prv][1];",
		  "        }else{",
		  "            const int res = update(ptr[prv][1], id, val, mid, r);",
		  "            ptr[cur][0] = ptr[prv][0], ptr[cur][1] = res;",
		  "        }",
		  "        ptr[cur][2] = min(ptr[ptr[cur][0]][2], ptr[ptr[cur][1]][2]);",
		  "        return cur;",
		  "    }",
		  "    void preprocessing(const vector<int>& vec){",
		  "        arr[0] = 0;",
		  "        for(int i = 0; i < n; ++i) arr[2 * i + 1] = vec[i], arr[2 * i + 2] = vec[i] + 1;",
		  "        sort(arr.begin(), arr.end());",
		  "        arr.erase(unique(arr.begin(), arr.end()), arr.end());",
		  "        m = (int)arr.size(), st[0] = 0, ptr.push_back({0, 0, -1});",
		  "        for(int i = 0; i < n; ++i){",
		  "            const int val = (int)(lower_bound(arr.begin(), arr.end(), vec[i]) - arr.begin());",
		  "            st[i + 1] = update(st[i], i, val, 0, m);",
		  "        }",
		  "    }",
		  "    int query(const int cur, const int cri, const int l, const int r){",
		  "        if(cur == 0 || r - l == 1) return arr[l];",
		  "        const int mid = (l + r) / 2;",
		  "        if(ptr[ptr[cur][0]][2] < cri) return query(ptr[cur][0], cri, l, mid);",
		  "        else return query(ptr[cur][1], cri, mid, r);",
		  "    }",
		  "public:",
		  "    RangeMexQuery(const vector<int>& vec) : n((int)vec.size()), arr(2 * n + 1), st(n + 1){",
		  "        preprocessing(vec);",
		  "    }",
		  "    int query(const int l, const int r){",
		  "        return query(st[r], l, 0, m);",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "rangeSet": {
		"prefix": "range_set_snippets",
		"body": [
		  "",
		  "// Ref: https://mugen1337.hatenablog.com/entry/2020/10/14/134022",
		  "// 閉区間の範囲を管理",
		  "template<typename T>",
		  "struct RangeSet{",
		  "    set<pair<T,T>> st;",
		  "    T TINF;",
		  " ",
		  "    RangeSet(){",
		  "        TINF=numeric_limits<T>::max()/2;",
		  "        st.emplace(TINF,TINF);",
		  "        st.emplace(-TINF,-TINF);",
		  "    }",
		  "    // [l,r] covered?",
		  "    bool covered(T l,T r){",
		  "        assert(l<=r);",
		  "        auto ite=prev(st.lower_bound({l+1,l+1}));",
		  "        return ite->first<=l and r<=ite->second;",
		  "    }",
		  "    bool covered(T x){",
		  "        return covered(x,x);",
		  "    }",
		  "    // [l, r]がカバーされているなら，その区間を返す. されていないなら[-TINF,-TINF]を返す",
		  "    pair<T,T> covered_by(T l,T r){",
		  "        assert(l<=r);",
		  "        auto ite=prev(st.lower_bound({l+1,l+1}));",
		  "        if(ite->first<=l and r<=ite->second) return *ite;",
		  "        return make_pair(-TINF,-TINF);",
		  "    }",
		  "    pair<T,T> covered_by(T x){",
		  "        return covered_by(x,x);",
		  "    }",
		  "    // insert[l,r], 増加量を返す",
		  "    T insert(T l,T r){",
		  "        assert(l<=r);",
		  "        auto ite=prev(st.lower_bound({l+1,l+1}));",
		  "        if(ite->first<=l and r<=ite->second) return T(0);",
		  "        T sum_erased=T(0);",
		  "        if(ite->first<=l and l<=ite->second+1){",
		  "            l=ite->first;",
		  "            sum_erased+=ite->second-ite->first+1;",
		  "            ite=st.erase(ite);",
		  "        }else ite=next(ite);",
		  "        while(r>ite->second){",
		  "            sum_erased+=ite->second-ite->first+1;",
		  "            ite=st.erase(ite);",
		  "        }",
		  "        if(ite->first-1<=r and r<=ite->second){",
		  "            sum_erased+=ite->second-ite->first+1;",
		  "            r=ite->second;",
		  "            st.erase(ite);",
		  "        }",
		  "        st.emplace(l,r);",
		  "        return r-l+1-sum_erased;",
		  "    }",
		  "    T insert(T x){",
		  "        return insert(x,x);",
		  "    }",
		  "    // erase [l,r], 減少量を返す",
		  "    T erase(T l,T r){",
		  "        assert(l<=r);",
		  "        auto ite=prev(st.lower_bound({l+1,l+1}));",
		  "        if(ite->first<=l and r<=ite->second){",
		  "            // 完全に1つの区間に包含されている",
		  "            if(ite->first<l)  st.emplace(ite->first,l-1);",
		  "            if(r<ite->second) st.emplace(r+1,ite->second);",
		  "            st.erase(ite);",
		  "            return r-l+1;",
		  "        }",
		  " ",
		  "        T ret=T(0);",
		  "        if(ite->first<=l and l<=ite->second){",
		  "            ret+=ite->second-l+1;// 消えた",
		  "            if(ite->first<l) st.emplace(ite->first,l-1);",
		  "            ite=st.erase(ite);// 次へ",
		  "        }else ite=next(ite);",
		  "        while(ite->second<=r){",
		  "            ret+=ite->second-ite->first+1;",
		  "            ite=st.erase(ite);",
		  "        }",
		  "        // 右端が区間の間にあるか",
		  "        if(ite->first<=r and r<=ite->second){",
		  "            ret+=r-ite->first+1;",
		  "            if(r<ite->second) st.emplace(r+1,ite->second);",
		  "            st.erase(ite);",
		  "        }",
		  "        return ret;",
		  "    }",
		  "    T erase(T x){",
		  "        return erase(x,x);",
		  "    }",
		  "    // number of range",
		  "    int size(){",
		  "        return (int)st.size()-2;",
		  "    }",
		  "    // mex [x,~)",
		  "    T mex(T x=0){",
		  "        auto ite=prev(st.lower_bound({x+1,x+1}));",
		  "        if(ite->first<=x and x<=ite->second) return ite->second+1;",
		  "        else return x;",
		  "    }",
		  "    void output(){",
		  "        cout<<\"RangeSet : \";",
		  "        for(auto &p:st){",
		  "            if(p.first==-TINF or p.second==TINF) continue;",
		  "            cout<<\"[\"<<p.first<<\", \"<<p.second<<\"] \";",
		  "        }",
		  "        cout<<\"\\n\";",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "dijkstra": {
		"prefix": "dijkstra_snippets",
		"body": [
		  "namespace dijkstra {",
		  "",
		  "    using ll = long long;",
		  "    using pl = std::pair<ll, ll>;",
		  "    constexpr ll inf = 1LL<<60;",
		  "",
		  "    std::pair<std::vector<ll>, std::vector<ll>> search(const std::vector<std::vector<pl>> &G, ll initial_pos) {",
		  "        std::vector<ll> from(G.size());",
		  "        std::vector<ll> dist(G.size(), inf);",
		  "        std::priority_queue<pl, std::vector<pl>, std::greater<pl>> que;",
		  "        dist[initial_pos] = 0;",
		  "        que.push({0, initial_pos});",
		  "        while(!que.empty()) {",
		  "            auto q = que.top();",
		  "            que.pop();",
		  "            auto cur_cost = q.first;",
		  "            auto cur_pos = q.second;",
		  "            if(cur_cost > dist[cur_pos]) continue;",
		  "            for(const auto& e : G[cur_pos]) {",
		  "                auto next_pos = e.first;",
		  "                auto next_cost = cur_cost + e.second;",
		  "                if(next_cost >= dist[next_pos]) continue;",
		  "                dist[next_pos] = next_cost;",
		  "                from[next_pos] = cur_pos;",
		  "                que.push({next_cost, next_pos});",
		  "            }",
		  "        }",
		  "        return make_pair(dist, from);",
		  "    }",
		  "",
		  "    std::pair<std::vector<ll>, std::vector<ll>> search(const std::vector<std::vector<ll>> &G, ll initial_pos) {",
		  "        std::vector<std::vector<std::pair<ll,ll>>> pseudoG(G.size());",
		  "        for(int i = 0; i < G.size(); i++) {",
		  "            for(const auto& e : G[i]) {",
		  "                pseudoG[i].push_back({e, 1});",
		  "            }",
		  "        }",
		  "        return search(pseudoG, initial_pos);",
		  "    }",
		  "",
		  "    std::vector<ll> restore(std::vector<ll>& from, ll start, ll goal) {",
		  "        assert(from[goal] != -1);",
		  "        std::vector<ll> res;",
		  "        ll cur = goal;",
		  "        while(cur != start) {",
		  "            res.push_back(cur);",
		  "            cur = from[cur];",
		  "        }",
		  "        res.push_back(cur);",
		  "        reverse(res.begin(), res.end());",
		  "        return res;",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "marathon_template": {
		"prefix": "marathon_template",
		"body": [
		  "struct rand_generator {",
		  "    random_device seed_gen;",
		  "    mt19937 engine;",
		  "    rand_generator() : engine(seed_gen()) {}",
		  "    int rand(int mod) {",
		  "        return engine() % mod;",
		  "    }",
		  "};",
		  "",
		  "struct timer {",
		  "    double global_start;",
		  "    double gettime() {",
		  "        struct timeval tv;",
		  "        gettimeofday(&tv, NULL);",
		  "        return tv.tv_sec + tv.tv_usec * 1e-6;",
		  "    }",
		  "    void init() {",
		  "        global_start = gettime();",
		  "    }",
		  "    double elapsed() {",
		  "        return gettime() - global_start;",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "geometry": {
		"prefix": "geo_snippets",
		"body": [
		  "#include <iostream>",
		  "#include <vector>",
		  "#include <algorithm>",
		  "#include <cmath>",
		  "",
		  "namespace geo {",
		  "    ",
		  "    template<class T = double>",
		  "    struct point2D {",
		  "        T x, y;",
		  "        point2D() : x(0), y(0) {}",
		  "        point2D(T x, T y) : x(x), y(y) {}",
		  "    };",
		  "",
		  "    template<class T = double>",
		  "    struct line2D {",
		  "        point2D<T> p1, p2;",
		  "        line2D() {}",
		  "        line2D(point2D<T> p1, point2D<T> p2) : p1(p1), p2(p2) {}",
		  "        T x1() { return p1.x; }",
		  "        T y1() { return p1.y; }",
		  "        T x2() { return p2.x; }",
		  "        T y2() { return p2.y; }",
		  "    };",
		  "",
		  "    template<class T>",
		  "    double dist(point2D<T> u, point2D<T> v) {",
		  "        double dx = u.x - v.x;",
		  "        double dy = u.y - v.y;",
		  "        double dist = sqrt(dx * dx + dy * dy);",
		  "        return dist;",
		  "    }",
		  "    ",
		  "    template<class T>",
		  "    double dist(line2D<T> line, point2D<T> point){",
		  "        double a = line.y2() - line.y1();",
		  "        double b = line.x2() - line.x1();",
		  "        double c = -line.x1() * a + line.y1() * b;",
		  "        double d = abs(a * point.x - b * point.y + c) / sqrt(a * a + b * b);",
		  "        return d;",
		  "    }",
		  "",
		  "    template<class T>",
		  "    bool cross(line2D<T> l1, line2D<T> l2){        ",
		  "        auto a = l1.p1, b = l1.p2;",
		  "        auto c = l2.p1, d = l2.p2;",
		  "        double s, t;",
		  "        s = (a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x);",
		  "        t = (a.x - b.x) * (a.y - d.y) - (a.y - b.y) * (a.x - d.x);",
		  "        if (s * t >= 0) return false;    ",
		  "        s = (c.x - d.x) * (c.y - a.y) - (c.y - d.y) * (c.x - a.x);",
		  "        t = (c.x - d.x) * (c.y - b.y) - (c.y - d.y) * (c.x - b.x);",
		  "        if (s * t >= 0) return false;",
		  "        return true;",
		  "    }",
		  "",
		  "}"
		],
		"description": ""
		}
		
}
